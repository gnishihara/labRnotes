---
title: 'R の基礎'
subtitle: |
          | 'R の基本操作の紹介とデータの入出力'
          | Updated: `r format(Sys.time(), "%Y-%m-%d %H:%M:%S")`
author: 
  - "GN Nishihara"
output:
  xaringan::moon_reader:
    css: xaringan-themer.css
    nature:
      slideNumberFormat: "%current% / %total%"
      highlightStyle: "monokai"
      highlightLines: true
      ratio: 16:9
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE, width = 120)
options(tikzDefaultEngine = "xetex")
# For a full width panelset plot use fig.width=6,fig.height = 2.5
# For half width plot  use fig.width = 3, fig.height=2.5
 
knitr::opts_chunk$set(
  fig.width=6, fig.height=2.5, fig.retina=3,
  out.width = "100%",
  cache = FALSE,
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  hiline = TRUE
)
Sys.setlocale("LC_TIME", "en_US.UTF-8") # This is to set the server time locate to en_US.UTF-8
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)
style_solarized_dark(
  code_font_family = "Fira Code",
  code_font_url = "https://cdn.jsdelivr.net/gh/tonsky/FiraCode@2/distr/fira_code.css"
)

library(xaringanExtra)
xaringanExtra::use_xaringan_extra(c("tile_view", "animate_css", "tachyons", "panelset"))
xaringanExtra::use_extra_styles(
  hover_code_line = T
)
xaringanthemer::style_extra_css(
  css = list(".small .remark-code" = list("font-size" = "0.6rem"),
             "li" = list(margin = "10px 0"),
             ".large li" = list("font-size" = "1.5rem"),
             ".title-slide h3" = list(color = "#006fc5"))
)

```

```{r, echo = FALSE}
library(tidyverse)
library(lubridate)
library(readxl)
library(knitr)
library(kableExtra)
library(magick)

options(knitr.kable.NA = '')
options(kableExtra.latex.load_packages = FALSE, tidyverse.quiet = TRUE)
```

## 目次

* [`r fontawesome::fa(name = "r-project")` の紹介・代入演算子・データ構造](#introduction)
* [`r fontawesome::fa(name = "r-project")` 関数の基本](#functions)
* [データの入出力](#data-io)
* [モダン `r fontawesome::fa(name = "r-project")` の紹介・データの入出力：`tidyverse`](#tidyverse)
* [データ加工・操作：`dplyr`](#tidyverse)
* [作図：`ggplot2`](#tidyverse)

---

## この資料・実習について

* `r fontawesome::fa(name = "r-project")` と RStudio はインストール済み
* `r fontawesome::fa(name = "r-project")`における単純計算方法はできる

* オレンジ色の文字はクリックできるリンクです。たとえば、下にある Fira Code についての文書はクリックできます。
* [Fira Code プログラミング用等幅フォントを使っています。](https://github.com/tonsky/FiraCode)
* このフォントにより、演算子は見やすくなります

**たとえば**

* `<-` は `<` と `-` の合字 (リガチャー, ligature) です `(ALT + -)`
* `|>` は `|` と `>` の合字です `(CTRL + SHIFT + M)`
* `<=` は `<` と `=` の合字です
* `!=` は `!` と `=` の合字です

**この資料は `r version$version.string` 環境で作りました。使用したパッケージは `xaringan` と `xaringanthemer` です。**

---

class: middle, center, inverse
name: introduction

# `r fontawesome::fa(name = "r-project")` の紹介

---

## R 統計解析プログラミング言語

* `r fontawesome::fa(name = "r-project")` は統計解析に特化したプログラミング言語です。
* `r fontawesome::fa(name = "r-project")` のルーツは 1970年代に Bell Laboratories で開発された S 言語です。
* `r fontawesome::fa(name = "r-project")` は1991年に University of Auckland, New Zealand の Ross Ihaka と Robert Gentleman が開発しました。

* 私は 2004 年から `r fontawesome::fa(name = "r-project")` を使っています。


---

## 代入演算子 (assignment operator) とベクトル (vector) とは

.pull-left[

* 代入は `=` か `<-` (`<` と `-`) です。伝統的に使われる代入は `<-` ですが、私は `=` を使っています。
* 左辺は変数名、右辺は値です。

```{r}
# 二種類の代入と c() 関数
a = 4.2
b <- 5.0
c(a, b)
```

* `c()` は渡された引数を結合します。
* `#` の後から続く文字列はコードとして実行されません。実行されない文書はコメントと呼びます。
]

.pull-right[

```{r}
(a + b) * c(a, b)
```

* R はベクトル処理という実行機構が特徴的です。
* 上のコードは $(a + b) \times a$ と $(a + b) \times b$ を求めています。
]

RStudio の場合 `<-` は `ALT + -` のショートカットを定義しています。

---

## R の主なデータタイプとデータ構造

.pull-left[

* 整数 integer
* 実数 double, numeric
* 複素数 complex number
* 時系列 time-series (POSIX)
* 文字列 character
* 論理値 logical
* 因子 factor
]

.pull-right[
* ベクトル　vector
* 配列 array, matrix
* リスト list
* テーブル（データフレーム） dataframe
]

---

## データの作り方

**ベクトル**
```{r}
a = c(10.3, 20.2, 30.1)
b = c("rabbit", "cat", "mouse", "dog")
d = c(TRUE, FALSE, T)
e = factor(c("nagasaki", "kagoshima", "fukuoka"))
```

**リスト**

ベクトルの長さは異なってもいい。
ここでは、リストの要素名を指定しました。

```{r}
z1 = list("A" = a, "B"= b, "D" = d, "E" = e)
```

**データフレーム**

ベクトルの長さを揃える必要がある。
ここでは`b[1:3]`を`b`に渡すことで、変数名を指定しました。

```{r}
z2 = data.frame(a, b = b[1:3], d, e)
```

---

## リストの構造を確認しよう

Rオブジェクトの構造 (structure) は `str()` で確認します。

```{r}
str(z1)
```

---

## リストからデータを抽出する

リストの要素は次のように抽出できます。

```{r}
z1$A
```

リストからの抽出方法は `$` 以外に, `[` や `[[` でもできます。

```{r, eval = FALSE}
z1[c("A", "D")]
z1[c(1,4)]
z1[[2]]
z1[[c(2,3)]]
z1[[2]][c(1,2)]
```

---

## データフレームの構造を確認しよう

```{r}
str(z2)
```

リストと似ていますが、そもそもデータフレームはリストです。
つまり、リストと同じように操作できます。

.pull-left[


```{r}
z2$a
```
]

.pull-right[

```{r, eval = FALSE}
z2[c("a", "d")]
z2[c(1, 4)]
z2[[2]]
z2[[c(2,3)]]
z2[[2]][c(1,2)]
```
]

---

## 比較演算

.pull-left[

* 比較に使う論理演算子：`&`（論理積 AND）, `|` （論理和 OR）, `!`（否定 NOT）

```{r}
A = c(5, 3, 2)
B = c(5, 2, 1)

# 論理積
(A[1] > B[1]) & (A[1] == B[1])
# 論理和
(A[1] > B[1]) | (A[1] == B[1])
```
]

.pull-right[

```{r}
# 否定と論理積
!(A[1] > B[1]) & (A[1] == B[1])

# 否定と論理和
(A[1] < B[2]) | !(A[1] == B[1])
```
]

---

## 比較演算を使ったデータの抽出

.pull-left[

```{r}
a = c(10.3, 20.2, 30.1)
b = c("rabbit", "cat", "mouse")
d = c(TRUE, FALSE, T)
e = factor(c("nagasaki", 
             "kagoshima", 
             "fukuoka"))
Z = data.frame(a, b, d, e)
Z[Z$a > 20, ]
```
]

.pull-right[
```{r}
Z[Z$a > 10 & Z$a < 20.2, ]
Z[Z$a > 10 & Z$a <= 20.2, ]
Z[identical(Z$a, 20) | !Z$d, ]
```

]

---

## **重要!** 数値を比較について

パソコンは 2 進数で計算しているので、数値は正確ではない！

**たとえば：**

```{r}
0.2 * 0.2 / 0.2 == 0.2 # = と =
```

数値の比較をする場合は `all.equal()` を使いましょう。

```{r}
all.equal(0.2 * 0.2 / 0.2, 0.2, tolerance = 0) # 上のコードと同じ
all.equal(0.2 * 0.2 / 0.2, 0.2, tolerance = .Machine$double.eps) # 機械誤差を考慮した比較
```

* ちなみに比較用記号は `<`, `>`, `>=` (`>` と `=`), `<=` (`<` と `=`), `!=` (`!` と `=`), `==` (`=` と `=`)　です。

---

class: middle, center, inverse
name: functions

# R 関数の基本

関数をつくることにより、`r fontawesome::fa(name = "r-project")` での作業がとても楽になります。
コードを繰り返して使うなら関数をつくりましょう。

---

## 関数の作り方

**R の関数に 2 つのパーツがあります。**

* **Arguments**: 引数
* **Code block**: 関数のコードは `{}` の間に納めます。

```{r, error = TRUE}
hello = function(x) {
  if(!is.character(x)) {
    stop("Please provide a character string.")
  }
  sprintf("Hello %s!", x)
}

hello(214)
hello("Yukio")
```

---

## 関数のスコープ (scope)（１）

関数の中に作ったものは、関数の中にしか存在しない。

```{r, echo = FALSE}
set.seed (2021)
```

```{r, error = TRUE}
sumofsquare = function(x) {
  ss = (x - mean(x))^2 # 関数の外から見れない
  ssq = sum(ss) # 関数の外から見れない
  ssq # 関数の外に返す
}
data = sample(1:10, 5, replace = TRUE)
data
value = sumofsquare(data)
value
ss
```

---

## 関数のスコープ (scope)（２）

ところが、関数は外の環境に存在するものは見れます。
このように関数を作ると、バグを起こしやすいので、注意。

```{r, error = TRUE}
sumofsquare = function(x) {
  ss = (s - mean(s))^2 # s は関数の外にあるが、関数の引数ではない
  ssq = sum(ss) # 関数の外から見れない
  ssq # 関数の外に返す
}
s = sample(100:1000, 5, replace = TRUE)
s
data = sample(1:10, 5, replace = TRUE)
data
value = sumofsquare(data)
value　# これは s の平方和です。
```

---

## 諸略した関数の書き方と無名関数 (anonymous function)

関数は次のようにもかけます。
`\(x){...}` はラムダ式 (lambda expression) とも呼ばれています。

```{r}
add_one = \(x) { x + 1}
add_one(5)
```

無名関数をつくるときに便利な書き方です。

```{r}
# どちれも無名関数ですが、２つ目の関数がはラムダ式です。
z = 1:5
sapply(z, FUN = function(s){s^2})
sapply(z, FUN = \(s){s^2})
```

---
class: middle, center, inverse
name: tidyverse

# `tidyverse` 

.left[

> Hadley Wickhamが開発した、タイディバースはRのプログラマーの中で最も使われているデータ分析パッケージです。
> データの読み込み、抽出、加工、可視化を助けてくれる関数の解析システムです。
> `tidyverse` の基礎となるアイディアは `tidy` な解析コードを開発することです。
つまり、だれでも読めるすぐに実行できるコードのことですね。
]

---

## `tidyverse`

`tidyverse` はメタパッケージなので、`library(tidyverse)` を実行すると次の 8 つのパッケージが読み込まれます。

* dplyr：データの変形・加工
* forcats：`factor()` 因子が使いやすくなります
* ggplot2：データの可視化・作図
* purrr ：関数型プログラミング
* readr ：CSV、TSVデータの読み込み
* stringr ：文字列の操作が楽になる
* tibble ：データフレームの操作が楽になる
* tidyr ：データをタイディ (tidy) にして操作しやすくなる

`tidyverse` の概念をもっと知りたい方は[tidyverse のマニフェスト](https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html)を読みましょう。

---

class: middle, center, inverse
name: data-io

# Data I/O

データ解析をするためには, データを `r fontawesome::fa(name = "r-project")` に読み込む必要があります。

ベースRの関数または外部パッケージの関数を使えば, 様々なデータファイルを簡単に読み込めます。

---

## `tibble` には list 列を入れられる

.pull-left[

ちょっと高度の方法ですが, list を変数の要素として記録できます。

```{r}
a1 = list(1,5,1,3,5,1)
a2 = list(2,3,5,2)
a3 = list("A","b","E")
tibble(a = 1:3, values = list(a1, a2, a3))
```

`values` 列は list の list ですね。
]
.pull-right[
```{r, echo = FALSE}

```

```{tikz, fig.ext = "png", echo = FALSE, engine.opts = list(template = "../tikz.latex"), out.width = "70%"}
\begin{tikzpicture}[
  hbox1/.style = {fill=blue!50,  draw=blue,  minimum width = 1.25cm, minimum height = 1.25cm},
  hbox2/.style = {fill=green!50, draw=green, minimum width = 1.25cm, minimum height = 1.25cm},
  box1/.style  = {fill=blue!10,  draw=blue,  minimum width = 1.25cm, minimum height = 1.25cm},
  box2/.style  = {fill=green!10, draw=green, minimum width = 1.25cm, minimum height = 1.25cm},
  sbox/.style  = {fill=green!10, draw=green, minimum width = 0.50cm, minimum height = 0.50cm}]

\node[name = h1, hbox1] {a};
\node[name = h2, hbox2, right=-\pgflinewidth/2 of h1] {values};
\node[name = b11, box1, below=-\pgflinewidth/2 of h1] {1};
\node[name = b21, box2, right=-\pgflinewidth/2 of b11] {list [6]};
\node[name = b12, box1, below=-\pgflinewidth/2 of b11] {2};
\node[name = b22, box2, right=-\pgflinewidth/2 of b12] {list [4]};
\node[name = b13, box1, below=-\pgflinewidth/2 of b12] {3};
\node[name = b23, box2, right=-\pgflinewidth/2 of b13] {list [3]};

\node[name = l6a, sbox, right= 0 of b21.east, anchor=south west] {1};
\node[name = l6b, sbox, right= 0 of l6a] {5};
\node[name = l6c, sbox, right= 0 of l6b] {1};
\node[name = l6d, sbox, below= 0 of l6a] {3};
\node[name = l6e, sbox, below= 0 of l6b] {5};
\node[name = l6f, sbox, below= 0 of l6c] {1};

\node[name = l5a, sbox, right= 0 of b22.east, anchor=south west] {2};
\node[name = l5b, sbox, right= 0 of l5a] {3};
\node[name = l5c, sbox, right= 0 of l5b] {5};
\node[name = l5d, sbox, below= 0 of l5a] {2};

\node[name = l3a, sbox, right= 0 of b23.east, anchor=west] {A};
\node[name = l3b, sbox, right= 0 of l3a] {b};
\node[name = l3c, sbox, right= 0 of l3b] {E};

\end{tikzpicture}
```

]

---

## 列名・変数名について

.pull-left[

`data.frame()` は無効な変数名を自動的に変更します。

```{r}
data.frame(`1 name` = 1) |> names()
```

`tibble()` はそのままにしてくれます。

```{r}
tibble(`1 name` = 1) |> names()
```
]

.pull-right[
```{r, echo = FALSE}
z = c("2021FY", "2021 FY", "2020-FY", "FY-2021")
z2 = make.names(z)
zout = stringr::str_glue("`{z}`") |> stringr::str_c(collapse = ", ")
zout2 = stringr::str_glue("`{z2}`") |> stringr::str_c(collapse = ", ")
```

**`data.frame()`の場合**
* **有効な変数名：**文字または、ドット(.)と文字から始まる文字列。変数名に使用できるものは文字、数字、ドットとアンダースコア (_) だけです。
* **無効な変数名の例：**`r zout` は自動的に `r zout2` に変更されます。

**`tibble()`の場合**
* 変数名はそのまま使えますが、使うときは `` ` `` `` ` `` （バクチック）に囲んでください。
]

**ところが!**
どうしても `data.frame()` に無効な変数名を使いたいのであれば、`check.names = F` を渡してください。

```{r}
data.frame(`1 name` = 1, check.names = FALSE) |> names()
```

---

## 引数を連続的に使える

`tibble()`はこのように, 計算処理をしながらデータフレームを構築できます。

```{r}
tibble(x = 1:4, `x^2` = x^2, `sqrt(x)` = sqrt(x))
```

---

## ベクトルをリサイクルしない

.pull-left[

二つのベクトルの長さが異なるときに, データフレームを作ると, 小さいほうのベクトルは先頭から繰り返して使われます。ただし長いベクトルの要素数は短いベクトルの要素数で除算できる必要があります。

```{r}
x = 1:4
y = 1:8
data.frame(x, y)
```
]

.pull-right[

ところが, この機能はデータ解析時にバグの原因になります。`tibble()`はベクトルのリサイクルはできません。

```{r, error=T}
x = 1:4
y = 1:8
tibble(x, y)
```
]

---

## I/O 関係の関数

**読み込み関数**

* `read_delim()`：一般性の高い関数, 区切りの指定が必要
* `read_csv()`：コンマ区切りフィアルの読み込み（csv ファイル）
* `read_table()`：ホワイトスペース区切りファイルの読み込み（タブ・スペース区切りファイル）
* `read_rds()`：R オブジェクトの読み込み

**書き出し関数**

* `write_delim()`：一般性の高い関数, 区切りの指定が必要
* `write_csv()`：コンマ区切りフィアルの書き出し
* `write_table()`：ホワイトスペース区切りファイルの書き出し（タブ・スペース区切りファイル）
* `write_rds()`：R オブジェクトの書き出し
* `ggsave()`: `ggplot2` でつくった図を書き出し

---

## `read_csv()` の重要な引数

* `file`：パスとファイル名
* `col_names = TRUE`：TRUEのとき, 1行目は列名として使う, FALSE のときは列名を自動的に作成する, 文字列ベクトルを渡せば読み込み中に列名を付けられます
* `col_types = NULL`：列のデータ型を指定できるが NULL のときは関数に任せる
* `comment = ""`：コメント記号を指定し, コメント記号後の文字を無視する
* `skip = 0`             先頭から無視する行数
* `locale`：ロケール（地域の設定）
* `n_max = Inf`：読み込む行数、デフォルトは全ての行数

---

## `read_csv()`の使い方

`read_csv()`
```{r,eval = FALSE}
rabbits = read_csv("Assignment_06_Dataset01.csv")
rabbits
```
```{r, echo = F}
filename = rprojroot::find_rstudio_root_file("introduction/Assignment_06_Dataset01.csv")
rabbits = read_csv(filename)
rabbits
```

---

## readxl パッケージ

`readxl` は Microsoft Excelファイルの読み込みに使えるパッケージです。

```{r, eval=F}
library(readxl)
```

ファイルの読み込みには `read_excel()` を使いますが、研究室では `read_xlsx()` もよく使います。
`read_excel()` は `read_xlsx()` のラッパーです。
使い方は全くおなじです。

**重要：** エクセルでデータの管理をした場合エクセルのオートコレクト機能によってデータがかってに変換されるので気をつけましょう。遺伝子の名前のオートコレクトによく問題が発生すると報告されています。とくに Excel と Google Sheets のオートコレクトはアグレッシブです。[Abeysooriya et al. 2021. PLOS Computational Biology](https://doi.org/10.1371/journal.pcbi.1008984)。

---

## `read_excel()` の主な引数

* `path`：パスとファイル名
* `sheet = NULL`：読み込むシート名またはシートインデックス
* `range = NULL`：読み込む範囲, 例えば "B3:D8" または, "Data!B3:D8"
* `col_names = TRUE`：1行目を列名として使う論理値
* `col_types = NULL`：読み込む列のデータ型を指定できます (デフォルトは guess)
* `na = ""`：欠損値の定義, 空セルは欠損値とされます
* `skip = 0`：無視する行数
* `n_max = Inf`：読み込む最大行数

---

## `read_excel()` の使用例（１）

最初のシート (`sheet = 1`) の先頭から1行無視して (`skip = 1`) データを読み込む。

```{r, eval = FALSE}
filename = "Table 2.xlsx"
exceldata = read_excel(filename, sheet = 1, skip = 1)
exceldata
```

```{r, echo = FALSE}
filename = rprojroot::find_rstudio_root_file("introduction/Table 2.xlsx")
exceldata = read_excel(filename, sheet=1, skip = 1)
exceldata
```

---

## `read_excel()` の使用例（２）

先程のように読み込むと、不都合な変数名に変換されました。次は、変数名も指定して読み込みます。

```{r, eval = FALSE}
filename = "Table 2.xlsx"
col_names = c("month", "temperature1", "sd1", "empty","temperature2", "sd2")
exceldata = read_excel(filename, sheet = 1, skip = 2, col_name = col_names)
exceldata |> print(n = 4)
```

```{r, echo = FALSE}
filename = rprojroot::find_rstudio_root_file("introduction/Table 2.xlsx")
col_names = c("month", "temperature1", "sd1", "empty","temperature2", "sd2")
exceldata = readxl::read_excel(filename, sheet=1, skip = 2, col_name = col_names)
exceldata |> print(n = 4)
```

シートの２行目には変数名が記録されているので、`skip = 2` を渡しました。

---

## データの出力

**CSVファイルの出力**

```{r, eval = FALSE}
fname = "table2_output.csv"
exceldata |> write_csv(file = fname) # 文字コードは UTF-8 です。
```

エクセルにCSVファイルを読み込んで文字化けした場合、`write_excel_csv()`を試してみてください。

```{r, eval = FALSE}
exceldata |> write_excel_csv(file = fname)
```

**RDSファイルの出力**

Rのオブジェクトをバイナリファイルとして保存したい場合は `write_rds()` を使います。

```{r, eval = FALSE}
fname = "table2_output.rds"
exceldata |> write_rds(file = fname)
```

---

class: middle, center, inverse
name: dplyr

# `dplyr` と `tidyr` によるデータ加工・操作

---

## 理想的なデータ構造


.large[
* 1 行 = 1 観測値
* 1 列 = 1 変数
]

---

## データ加工・操作用関数

**データの結合 (mutating join)**

`x`, `y`, `by` は関数の引数です。`by` で指定したキー（変数名）が一致するように行を合わせることができる。

* `full_join(x, y, by)`：全ての `x` と `y` 行と列を結合する。
* `inner_join(x, y, by)`：`x` と `y` で共通する行と列を結合する。
* `left_join(x, y, by)`：左側（）第 1 引数のtibble に `y` の変数を追加する。
* `right_join(x, y, by)`：右側（）第 2 引数のtibble に `x` の変数を追加する。


**データの結合 (join)**

* `bind_cols()`：渡したtibbleを横に結合する（行数が異なったらエラーが発生する）。
* `bind_rows()`：渡した tibble を立てに結合する（一致する変数名を合わせてくれます）。

---

## mutating join のつかいかた

.panelset[
.panel[.panel-name[tibble]
```{r}
X = tibble(x = c("A", "B", "C", "G"), y = c(NA, rnorm(3, mean = 5)))
Y = tibble(x = c("A", "C", "D", "E"), z = c(rpois(3, lambda = 5), NA))
```
.pull-left[
```{r}
X
```
]
.pull-right[
```{r}
Y
```
]
]
.panel[.panel-name[full_join()]
```{r}
full_join(X,Y, by = "x")
```
]
.panel[.panel-name[inner_join()]

```{r}
inner_join(X, Y, by = "x")
```
]
.panel[.panel-name[left_join()]

```{r}
left_join(X, Y, by = "x")
```
]
.panel[.panel-name[right_join()]

```{r}
right_join(X, Y, by = "x")
```
]
.panel[.panel-name[bind_rows()]
.pull-left[
```{r}
bind_rows(X, Y)
```

]
.pull-right[
```{r}
bind_rows("X" = X, "Y" = Y, .id = "origin")
```
]
]
.panel[.panel-name[bind_cols()]
```{r}
bind_cols(X, Y)
```
]
]

---

## 行と列の加工・操作用関数

.pull-left[
**列における操作**

* `mutate()`：既存の変数の書き換えや変数の追加する
* `select()`：既存の変数を選らぶ
* `rename()`：既存の変数の名前を変える
* `pull()`：既存の変数をリストとして抽出する
* `relocate()``：指定した列の位置を変える
]

.pull-right[
**行における操作**

* `filter()`：条件を満たした行を返す
* `distinct()`：指定した変数から重複している行を外す
* `slice()`：指定した行インデックスを返す
* `arrange()`：指定した列の昇順で行を並べ替える
]

---

## 列の加工

.panelset[
.panel[.panel-name[mutate()]
```{r}
iris |> as_tibble() |> mutate(P2 = Petal.Length^2)
```
]
.panel[.panel-name[select()]
.pull-left[
```{r}
iris |> as_tibble() |> select(Species, Petal.Length)
```
]
.pull-right[
```{r}
iris |> as_tibble() |> select(matches("Length"))
```
]
]
.panel[.panel-name[rename()]
.pull-left[
.small[
```{r}
iris |> as_tibble() |> rename(PL = Petal.Length)
```
]
]
.pull-right[
.small[

```{r}
iris |> as_tibble() |> 
  rename_with(~str_replace_all(.x, "[(a-z.)]", ""), .cols = matches("(Pet)|(Sep)"))
```
]
]

]
.panel[.panel-name[pull()]
.small[

```{r}
iris |> as_tibble() |> pull(Species)
```
]

]
.panel[.panel-name[relocate()]
.pull-left[
.small[

```{r}
iris |> as_tibble() |> relocate(Species, .before = "Sepal.Length")
```
]
]

.pull-right[
.small[
```{r}
iris |> as_tibble() |> relocate(Species, matches("Length"), .before = "Sepal.Length")
```
]
]

]
]

---

## 行の加工

.panelset[
.panel[.panel-name[filter()]
.pull-left[
.small[

```{r}
iris |> as_tibble() |> filter(str_detect(Species, "versicolor"))
```
]
]
.pull-right[

.small[
```{r}
iris |> as_tibble() |> filter(Petal.Length > 6 & Sepal.Length > 7.5)
```
]]]
.panel[.panel-name[distinct()]
.pull-left[
```{r}
iris |> as_tibble() |> distinct(Species)
```
]
.pull-right[
.small[
```{r}
iris |> as_tibble() |> distinct(Petal.Length, .keep_all = T)
```
]]]
.panel[.panel-name[slice()]
.pull-left[
.small[
```{r}
iris |> as_tibble() |> slice(1:5)
iris |> as_tibble() |> slice_head(n = 2)
iris |> as_tibble() |> slice_tail(n = 2)
```
]]
.pull-right[
.small[
```{r}
iris |> as_tibble() |> slice_min(Petal.Length)
iris |> as_tibble() |> slice_max(Petal.Length)
iris |> as_tibble() |> slice_sample(n = 3)
```
]]]
.panel[.panel-name[arrange()]
.pull-left[
.small[
```{r}
iris |> as_tibble() |> arrange(Sepal.Length)
```
]]
.pull-right[
.small[
```{r}
iris |> as_tibble() |> 
  arrange(desc(Sepal.Length), desc(Sepal.Width))
```
]]]
]

---

## グループ化・ネストに関する関数

* `group_by()`：`tibble` をグループ化する
* `group_nest()`：グループ化した `tibble` をネスト（入れ子）する
* `nest()`：渡した列をネストする
* `unnest()`：ネストされている列を展開（アンネスト）する
* `group_map()`：グループ化した `tibble` に関数を適応して、リストを返す
* `group_modify()`：グループ化した `tibble` に関数を適応して、tibble を返す

---

## `tibble` のグループ化

.panelset[
.panel[.panel-name[group_by()]
.pull-left[
```{r}
iris |> as_tibble() |> select(1:3)
```
]

.pull-right[
.small[

```{r}
iris |> as_tibble() |> group_by(Species) |> select(1:3)
```
]]]

.panel[.panel-name[group_nest()]
.small[
```{r}
iris |> as_tibble() |> group_nest(Species)
```
]]

.panel[.panel-name[nest()]
.small[
```{r}
iris |> as_tibble() |> nest(data = matches("Length|Width"))
```
]]

.panel[.panel-name[unnest()]
.small[
```{r}
iris |> as_tibble() |> group_nest(Species) |> unnest(data)
```
]]
.panel[.panel-name[group_map()]
.small[
```{r}
iris |> as_tibble() |> group_by(Species) |> group_map(~head(.x, n = 2))
```
]]
.panel[.panel-name[group_modify()]
.small[
```{r}
iris |> as_tibble() |> group_by(Species) |> group_modify(~head(.x, n = 2))
```
]]
]

---

## その他の関数

.pull-left[
* `drop_na()`：`NA`（欠損値）を含む行を削除
* `replace_na()`：`NA`を他の値と書き換える
* `fill()`：`NA`を直前の値で埋める
]
.pull-right[
* `separate()`：文字列の変数を任意の区切りで複数変数に分裂する
* `unite()`：複数の変数を任意の区切りで 1 列にまとめる
]


.panelset[
.panel[.panel-name[drop_na()]
.pull-left[
```{r}
X
```
]
.pull-right[
```{r}
X |> drop_na()
```
]
]
.panel[.panel-name[replace_na()]
.pull-left[
```{r}
X |> replace_na(list(x = "Z", y = 0))
```
]
.pull-right[
```{r}
X |> mutate(y = replace_na(y, 0))
```

]
]
.panel[.panel-name[fill()]
```{r}
Y |> fill(z)
```
]
.panel[.panel-name[separate()]
```{r}
tibble(x = c(NA, "Iris.setosa", "Iris.virginica", "Iris.versicolor")) |> 
  separate(x, into = c("Genus", "Species"))
```
]
.panel[.panel-name[unite()]
```{r}
tibble(x = rep("Iris", 3), y = c("setosa", "virginica", "versicolor")) |> 
  unite(Species, x, y, sep = "_")
```
]
]

---

## ピボット・`tibble`を変形する関数

* `pivot_longer()`：`tibble` を wide format （横広）から long format （縦長）に変える
* `pivot_wider()`：`tibble` をlong format から wide format に変える

-------------------

### 重要な引数

.pull-left[
`pivot_longer()`

* `cols`：動かす変数
* `names_to`：動かした変数の名前の移動先
* `values_to`：動かした変数の値の移動先
* `names_transform`：移動先の変数のタイプを変換

]
.pull-right[
`pivot_wider()`

* `id_cols`：行（値）を区別するための列名
* `names_from`：移動先の列名になる変数
* `values_from`：移動したい値
* `values_fill`：存在しない要素の埋め込み方法
* `values_fn`：行の区別ができないときの処理（デフォルトはリスト）

]


---

## `pivot_longer()` の使い方

.panelset[
.panel[.panel-name[pivot_longer() 1]
.pull-left[
.small[
```{r}
relig_income |> as_tibble()
```
]]

.pull-right[
.small[
```{r}
relig_income |> as_tibble() |> 
pivot_longer(!religion, names_to = "income", values_to = "count")
```
]]]

.panel[.panel-name[pivot_longer() 2]
.pull-left[
.small[
```{r}
billboard |> as_tibble()
```
]]
.pull-right[
.small[
```{r}
billboard |> as_tibble() |> 
  pivot_longer(col = starts_with("wk"),
               names_to = "week", names_prefix = "wk",
               values_to = "rank", values_drop_na = TRUE)
```
]]]

.panel[.panel-name[pivot_longer() 3]
.pull-left[
.small[
```{r}
who |> as_tibble()
```
]]
.pull-right[
.small[
```{r}
who %>% as_tibble() |>
  pivot_longer(cols = new_sp_m014:newrel_f65,
               names_to = c("diagnosis", "gender", "age"),
               names_pattern = "new_?(.*)_(.)(.*)",
               values_to = "count", values_drop_na = TRUE)

```
]]]

.panel[.panel-name[pivot_longer() 4]
.pull-left[
.small[
```{r}
anscombe |> as_tibble()
```
]]
.pull-right[
.small[
```{r}
anscombe %>% as_tibble() |> 
 pivot_longer(everything(), names_to = c(".value", "set"), names_pattern = "(.)(.)"
 )
```
]]]
]


---

## `pivot_wider()` の使い方

.panelset[
.panel[.panel-name[pivot_longer() 1]
.pull-left[
.small[
```{r}
fish_encounters
```
]]

.pull-right[
.small[
```{r}
fish_encounters |> as_tibble() |> 
  pivot_wider(names_from = station, values_from = seen)
```
]]]

.panel[.panel-name[pivot_longer() 2]
.pull-left[
.small[
```{r}
fish_encounters
```
]]

.pull-right[
.small[
```{r}
# 存在しない組み合わせの要素を埋める
fish_encounters |>  as_tibble() |> 
  pivot_wider(names_from = station, values_from = seen, values_fill = 0)

```
]]]

.panel[.panel-name[pivot_longer() 3]
.pull-left[
.small[
```{r}
us_rent_income |> as_tibble()
```
]]
.pull-right[
.small[
```{r}
us_rent_income |> as_tibble() |> 
  pivot_wider(names_from = variable, values_from = c(estimate, moe))

# us_rent_income  |> as_tibble() |> 
#   pivot_wider(names_from = variable,
#               names_sep = ".",
#               values_from = c(estimate, moe))

# us_rent_income  |> as_tibble() |> 
#   pivot_wider(names_from = variable,
#               names_glue = "{variable}_{.value}",
#               values_from = c(estimate, moe))
```
]]]

.panel[.panel-name[pivot_longer() 4]
.pull-left[
.small[
```{r}
warpbreaks |> as_tibble()
```
]]
.pull-right[
.small[
```{r}
warpbreaks |> as_tibble() |> 
  pivot_wider(names_from = wool,
              values_from = breaks)

```
]]]

.panel[.panel-name[pivot_longer() 5]
.pull-left[
.small[
```{r}
warpbreaks |> as_tibble()
```
]]

.pull-right[
.small[
```{r}
warpbreaks |> as_tibble() |> 
  pivot_wider(names_from = wool,
              values_from = breaks,
              values_fn = mean)

```
]]]
]


---

## 不都合なデータ構造

```{r, include = F, cache=TRUE}
# 光合成曲線疑似データ
set.seed(2021)
f1 = \(x, p) {p[1] * (1-exp(-p[2] / p[1] * x)) - p[3]} 
p = 32*c(80, 5, 30)
z = tibble(light = c(seq(0, 45, by  = 5), seq(50, 100, by = 25))) |> 
  mutate(yhat = f1(light, p))

z = tibble(min = seq(0, 30, by = 5), data = list(z)) |> 
  unnest(data) |> 
  mutate(umol = min * yhat/10000 + 10) 

z = tibble(sample = 1:10, data = list(z)) |> 
  mutate(data = map(data, \(x) {
    x |> 
      mutate(umol = rnorm(n(), umol, sd = 0.1))
  })) |> 
  unnest(data) |> 
  select(-yhat) |> 
  pivot_wider(id_cols = c(sample, min),
              names_from = light,
              values_from = umol)
z |> arrange(min, z) |> 
  filter(sample <6) |> 
  select(sample, min, matches("((5[0-9])|(7[0-9])|(10[0-9]))")) |> 
  write_csv("photosynthesis1_high.csv")
  
z |> arrange(min, z) |> 
  filter(sample <6) |> 
  select(!matches("((5[0-9])|(7[0-9])|(10[0-9]))")) |> 
  write_csv("photosynthesis1_low.csv")

z |> arrange(min, z) |> 
  filter(sample > 5) |> 
  select(sample, min, matches("((5[0-9])|(7[0-9])|(10[0-9]))")) |> 
  write_csv("photosynthesis2_high.csv")
  
z |> arrange(min, z) |> 
  filter(sample > 5) |> 
  select(!matches("((5[0-9])|(7[0-9])|(10[0-9]))")) |> 
  write_csv("photosynthesis2_low.csv")
```
```{r readphoto, include = F, cache=TRUE}
fname = rprojroot::find_rstudio_root_file("photosynthesis1_low.csv")
dset1_low = read_csv(fname)
fname = rprojroot::find_rstudio_root_file("photosynthesis1_high.csv")
dset1_high = read_csv(fname)
fname = rprojroot::find_rstudio_root_file("photosynthesis2_low.csv")
dset2_low = read_csv(fname)
fname = rprojroot::find_rstudio_root_file("photosynthesis2_high.csv")
dset2_high = read_csv(fname)
```

```{r, eval = FALSE}
fname = "photosynthesis1_low.csv"
dset1_low = read_csv(fname)
```


```{r}
dset1_low
```

`sample` と `min` の列はサンプル番号と時間 (minutes) の変数です。
それぞれに、サンプル番号と時間の値が入っています。
`0` から `45` の列には溶存酸素濃度の値が入っています。
この時の変数名は光条件ですね。

---

## ワイドからロングへ変換

```{r}
dset1_low |> 
  pivot_longer(cols = matches("[0-9]+"),　names_to = "light",
               names_transform  = list(light = as.numeric))
```

---

## 残りのデータの読み込み


```{r, eval = FALSE}
dset1_high = read_csv("photosynthesis1_high.csv")
dset2_low  = read_csv("photosynthesis2_low.csv")
dset2_high = read_csv("photosynthesis2_high.csv")
```

---

## ピボットしてから結合

```{r}
dset1_low  = dset1_low  |> pivot_longer(cols = matches("[0-9]+"), names_to = "light", names_transform = list(light = as.numeric))
dset1_high = dset1_high |> pivot_longer(cols = matches("[0-9]+"), names_to = "light", names_transform = list(light = as.numeric))
dset2_low  = dset2_low  |> pivot_longer(cols = matches("[0-9]+"), names_to = "light", names_transform = list(light = as.numeric))
dset2_high = dset2_high |> pivot_longer(cols = matches("[0-9]+"), names_to = "light", names_transform = list(light = as.numeric))
alldata = bind_rows(dset1_low, dset2_low, dset1_high, dset2_high)
alldata
```

---

## 結合してからピボット

```{r, ref.label="readphoto", echo=F}
```

```{r}
dset1 = full_join(dset1_low, dset1_high, by = c("sample", "min"))
dset2 = full_join(dset2_low, dset2_high, by = c("sample", "min"))
alldata = bind_rows(dset1, dset2)
alldata = alldata |> 
  pivot_longer(cols = matches("[0-9]+"), names_to = "light", 
               names_transform = list(light = as.numeric))
```


---
class: middle, center, inverse
name: ggplot

# `ggplot2` による作図

---

## `ggplot2` について

* `ggplot2` の関数は `+` でつなげる
* `ggplot()` はベースレイヤー
* `geom_*()` はプロットレイヤー
* `scales_*()` でエステティク (aesthetics) を調整
* `theme()` や `theme_()` で書式を調整
* `facet_wrap()` や `facet_grid()` は多変量データのプロットのパネル分け
---

## Aesthetics （エステティク）とは

.pull-left[
### 色・透明度

* `color`：点と線の色
* `fill`：面の色
* `alpha`：透明度（0 -- 1 の値）

### 大きさ・形状

* `size`：点と文字の大きさ、線の太さ
* `shape`：点の形
* `linetype`：線の種類

]

.pull-right[
### グループ化

* `group`：点や線のグループ化

### 座標、始点・終点

* `x`, `y`
* `xmin`, `ymin`
* `xend`, `yend`

]

---

## geom の種類

.pull-left[
**散布図**

* `geom_point()`
* `geom_jitter()`

**折れ線グラフ**

* `geom_path()`
* `geom_line()`
* `geom_step()`

**面グラフ**
* `geom_ribbon()`
* `geom_area()`
* `geom_polygon()`

]

.pull-right[
**ヒートマップ・コンター図**
* `geom_tile()`
* `geom_raster()`
* `geom_rect()`
* `geom_contour()`

**エラーバー**
* `geom_error()`
* `geom_linerange()`
* `geom_pointrange()`
* `geom_crossbar()`
]

---

## geom の種類

.pull-left[
**曲線など**

* `geom_smooth()`
* `geom_curve()`
* `geom_segment()`
* `geom_abline()`
* `geom_hline()`
* `geom_vline()`

**文字列**

* `geom_text()`
* `geom_label()`

]

.pull-right[
**ヒストグラム・密度曲線**
* `geom_histogram()`
* `geom_freqpoly()`
* `geom_density()`
* `geom_bin2d()`
* `geom_hex()`
* `geom_dotplot()`

**棒グラフ・箱ひげ図**
* `geom_bar()`
* `geom_col()`
* `geom_boxplot()`
* `geom_violin()`
]

---

## `ggplot2` の付属パッケージ

**研究室が使っているパッケージ**

* `ggpubr`: `theme_pubr()`, `ggarrange()`
* `ggrepel`: `geom_text_repel()`
* `lemon`: `facet_rep_grid()`, `facet_rep_wrap()`
* `showtext`: システムフォントの埋め込み

[ggplot2 extensions](https://exts.ggplot2.tidyverse.org/)

---




## データを読み込んだら、可視化しよう

```{r, echo = FALSE}
# Need to make sure that show text is not enabled.
if("showtext" %in% (.packages())){
  showtext_auto(enable = FALSE)
}
theme_replace(text = element_text(family = "sans"))
```

```{r, fig.height=2}
ggplot(exceldata) + geom_point(aes(x = month, y = temperature1))
```

横軸の順序がおかしいですね。軸タイトルも変えたほうがいいですね。

---

## 軸タイトルの関数

軸タイトルや図のタイトルは `labs()` 関数でします。

.panelset[
```{r, panelset = TRUE, fig.height=2}
xlabel = "Month"
ylabel = "'Temperature ('*degree*'C)'" # plotmath expression see ?plotmath
ggplot(exceldata) + 
  geom_point(aes(x = month, y = temperature1)) + 
  labs(x = xlabel, 
       y = parse(text = ylabel),
       title = "Monthly mean water temperature") 
```
]

---

## 論文用に変える

学術論文に記載する図の場合、図から余計なかざりを外します。
研究室では `ggpubr` の `theme_pubr()` 関数を使っています。

.panelset[
```{r, panelset = TRUE, fig.height=2}
library(ggpubr)
xlabel = "Month"
ylabel = "'Temperature ('*degree*'C)'" # plotmath expression see ?plotmath
ggplot(exceldata) + 
  geom_point(aes(x = month, y = temperature1)) + 
  labs(x = parse(text = xlabel), 
       y = parse(text = ylabel))  +
  theme_pubr(base_size = 10)
```
]

---

## フォントを指定する

`showtext` パッケージは図にシステムフォントを入れるために使います。
システムフォントの他に、Google のウェッブフォントも使えます。
```{r}
library(showtext)
```

Google のウェッブフォントは `font_add_google()` を使います。
```{r}
font_add_google(name = "Noto Sans", family = "notosans")
font_add_google(name = "Noto Sans JP", family = "notosans-jp") # 日本語フォント
```

`notosans` をデフォルトして設定します。
```{r}
showtext_auto()
theme_replace(text = element_text(family = "notosans"))
```

---

## 月の順序をなおす

もう気づいたと思いますが、横軸の月の順序が間違っています。
`factor()` で、`month` 変数を整えます。

.panelset[
```{r, panelset = TRUE, fig.height=2}
# element_text() size is in points (pt)
# 1 pt = 0.35 mm

library(ggpubr)
xlabel = "Month"
ylabel = "'Temperature ('*degree*'C)'" # plotmath expression see ?plotmath

levels = month.abb
levels = str_c(levels, ifelse(levels == "May", "", "."))

exceldata |> 
  mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_point(aes(x = month, y = temperature1)) + 
  labs(x = parse(text = xlabel), 
       y = parse(text = ylabel))  +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))

```

]


```{r, echo = FALSE}
library(magick)
pout = exceldata |> 
  mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_point(aes(x = month, y = temperature1)) + 
  labs(x = parse(text = xlabel), 
       y = parse(text = ylabel))  +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))

pdffile = rprojroot::find_rstudio_root_file("temperature_plot.pdf")
pngfile = rprojroot::find_rstudio_root_file("temperature_plot.png")
wh = c(80, 80)
ggsave(pdffile, plot = pout, width = wh[1], height = wh[2], units = "mm", device = cairo_pdf)
ggsave(pngfile, plot = pout, width = wh[1], height = wh[2], units = "mm", dpi = 300)

i1 = image_read_pdf(pdffile, density = 236) |> image_resize("x500") 
i2 = image_read(pngfile)|> image_resize("x500") 

```

---

## 図を保存する

図は PDF と PNG 形式で保存しましょう。

**PDFファイル**
`ggsave()` は最後の表示した図を書き出しします。
`width` と `height` を指定したら必ず単位も指定しましょう (`units = "mm"`)。
PDFファイルにシステムフォントを埋め込むなら、`device = cairo_pdf`も渡しましょう。

```{r, eval = FALSE}
wh = list(width = 80, height = 80) # 図の縦横幅
pdffile = "temperature_plot.pdf"
ggsave(pdffile, width = wh$width, height = wh$height, units = "mm", device = cairo_pdf)
```

**PNGファイル**
直接PNGファイルに保存する場合は、画像の解像度 (`dpi = 300`) も必要です。
```{r, eval = FALSE}
pngfile = "temperature_plot.png"
ggsave(pngfile, width = wh$width, height = wh$height, units = "mm", dpi = 300)
```

---

## 保存の結果

```{r, echo = FALSE, out.width="75%", fig.align="center"}
img3 = image_blank(10, 500, color = "#002b36")
image_append(c(i1, img3, i2)) |> 
  image_annotate("PDF", location = "+400+0", size = 36, color = "#002b36", font = "Noto Sans") |>
  image_annotate("PNG", location = "+900+0", size = 36, color = "#002b36", font = "Noto Sans") 
```


* `wh = list(width = 80, height = 80)` は同じだが、図は似ていません。
* モニターでみたとき、PDF の解像度は 96 です。つまり、`dpi = 300` のPNGファイルはPDFの約 3 倍の大きさです。

---

## 図のフォントを拡大して、PNGファイルを修正する

.panelset[
.panel[.panel-name[Code]
```{r, include = FALSE, cache = F}
DPI = 300
# When done in xaringan the denominator is (72 / ggplot2::.pt).
# But when done in an R script, the denominator is 96.
# If this code is run in RStudio, use the second line.
scale = DPI / 72 / .pt
# scale = DPI / 96
wh = list(width = 80, height = 80)
pdffile = rprojroot::find_rstudio_root_file("temperature_plot2.pdf")
pngfile = rprojroot::find_rstudio_root_file("temperature_plot2.png")

pout = exceldata |> 
  mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_point(aes(x = month, y = temperature1)) + 
  labs(x = parse(text = xlabel), 
       y = parse(text = ylabel))  +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))

ggsave(pdffile, plot = pout, width = wh$width, height = wh$height, units = "mm", dev = cairo_pdf)

pout = exceldata |> 
  mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_point(aes(x = month, y = temperature1)) + 
  labs(x = parse(text = xlabel), 
       y = parse(text = ylabel))  +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10 * scale))

ggsave(pngfile, plot = pout, width = wh$width, height = wh$height, units = "mm", dpi = DPI)

i1 = image_read_pdf(pdffile, density = 600) |> image_resize("x500") 
i2 = image_read(pngfile)|> image_resize("x500") 

```

```{r, eval = FALSE}
DPI = 300
scale = DPI / 96
exceldata |> 
  mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_point(aes(x = month, y = temperature1)) + 
  labs(x = parse(text = xlabel), 
       y = parse(text = ylabel))  +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10 * scale))

pngfile = "temperature_plot.png"
wh = list(width = 80, height = 80)
ggsave(pngfile, width = wh$width, height = wh$height, units = "mm", dpi = DPI)

```

]

.panel[.panel-name[Result]
```{r panel, echo = FALSE, out.width="75%", fig.align="center"}
img3 = image_blank(10, 500, color = "#002b36")
image_append(c(i1, img3, i2)) |> 
  image_annotate("PDF", location = "+400+0", size = 36, color = "#002b36", font = "Noto Sans") |>
  image_annotate("PNG", location = "+910+0", size = 36, color = "#002b36", font = "Noto Sans") 
```
]
]

---

## 研究室のワークフロー

PNGファイルのDPIをいじるのが面倒なので、PDFをPNGに変換するのが楽です。
月の頭文字をチックラベルにします。さらに、`lemon` パッケージの `geom_pointline()`を使ってみました。

.panelset[
.panel[.panel-name[ggplot2]
```{r}
library(lemon)
xlabel = "Month"
ylabel = "'Temperature'~(degree*C)" # plotmath expression see ?plotmath
levels = month.abb
levels = str_c(levels, ifelse(levels == "May", "", "."))
labels = str_sub(month.abb, 1, 1)
# 図の結果は plot1 にいれます。
plot1 =   exceldata |> mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_point(aes(x = month, y = temperature1)) +
  scale_x_discrete(name = xlabel, labels = labels) +
  scale_y_continuous(name = parse(text = ylabel), breaks = seq(21, 29, by = 1)) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))
```
]
.panel[.panel-name[ggsave]

まず、PDFファイルを保存します。システムフォントをPDFファイルに入れるためには `device = cairo_pdf` を渡します。

```{r, echo = FALSE}
library(magick) # imagemagick パッケージ
wh = list(width = 80, height = 80) # 図の縦横幅
pdffile = rprojroot::find_rstudio_root_file("temperature_plot.pdf")
pngfile = rprojroot::find_rstudio_root_file("temperature_plot.png")
ggsave(pdffile, width = wh$width, height = wh$height, units = "mm", device = cairo_pdf)
```

```{r, eval = FALSE}
wh = list(width = 80, height = 80) # 図の縦横幅
pdffile = "temperature_plot.pdf"
ggsave(pdffile, width = wh$width, height = wh$height, units = "mm", device = cairo_pdf)
```
]
.panel[.panel-name[magick]

ImageMagick のAPIを使って、PDFをPNGに変換します。
この方法だと、DPIのややこしい変換は不要です。

つぎに `magick` パッケージを読み込みます。

```{r, eval = FALSE}
library(magick) # imagemagick パッケージ
```

つづいて、PDF ファイルを 600 DPI で読み込む。
```{r, eval = FALSE}
img = image_read_pdf(pdffile, density = 600)
```

PDFファイルをPNGファイルに書き出す。

```{r, eval = FALSE}
img |> image_write(pngfile)
```

]
]

---

## 保存の結果

```{r panel2, echo = FALSE, out.width = "80%", fig.align="center"}
pdffile = rprojroot::find_rstudio_root_file("temperature_plot.pdf")
pngfile = rprojroot::find_rstudio_root_file("temperature_plot.png")
img = image_read_pdf(pdffile, density = 600)
img |> image_write(pngfile)
img = img |> image_resize("x500")
img2 = image_read(pngfile)|> image_resize("x500")
img3 = image_blank(10, 500, color = "#002b36")
image_append(c(img, img3, img2)) |> 
  image_annotate("PDF", location = "+400+0", size = 36, color = "#002b36", font = "Noto Sans") |>
  image_annotate("PNG", location = "+910+0", size = 36, color = "#002b36", font = "Noto Sans") 
```

このとき、フォントサイズは 10 pt にしました：`theme(text = element_text(size = 10))`。

---

## データを追加してプロット

.pull-left[
```{r, eval = FALSE}
library(viridis)
xlabel = "Month"
ylabel = "'Temperature'~(degree*C)" # plotmath expression see ?plotmath
levels = month.abb
levels = str_c(levels, ifelse(levels == "May", "", "."))
labels = str_sub(month.abb, 1, 1)
exceldata |> mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_pointline(aes(x = month, y = temperature1, color = "Group 1", shape = "Group 1", group = 1)) +
  geom_pointline(aes(x = month, y = temperature2, color = "Group 2", shape = "Group 2", group = 1)) +
  scale_x_discrete(name = xlabel, labels = labels) +
  scale_y_continuous(name = parse(text = ylabel), breaks = seq(15, 30, by = 5), limits = c(15, 30)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, begin = 0, end = 0.5) +
  scale_shape_discrete("") +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(1, 0),
        legend.justification = c(1, 0),
        legend.background = element_blank(),
        legend.title = element_blank())
```
]
.pull-right[

```{r, fig.width = 3, fig.height = 2.5, echo = FALSE}
library(viridis)
xlabel = "Month"
ylabel = "'Temperature'~(degree*C)" # plotmath expression see ?plotmath
levels = month.abb
levels = str_c(levels, ifelse(levels == "May", "", "."))
labels = str_sub(month.abb, 1, 1)
exceldata |> mutate(month = factor(month, levels = levels)) |> 
  ggplot() + 
  geom_pointline(aes(x = month, y = temperature1, color = "Group 1", shape = "Group 1", group = 1)) +
  geom_pointline(aes(x = month, y = temperature2, color = "Group 2", shape = "Group 2", group = 1)) +
  scale_x_discrete(name = xlabel, labels = labels) +
  scale_y_continuous(name = parse(text = ylabel), breaks = seq(15, 30, by = 5), limits = c(15, 30)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, begin = 0, end = 0.5) +
  scale_shape_discrete("") +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(1, 0),
        legend.justification = c(1, 0),
        legend.background = element_blank(),
        legend.title = element_blank())
```
]

---

## 複数パネルのプロット

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.0}
xlabel = "Petal width (cm)"
ylabel = "Sepal width (cm)"
iris |> group_nest(Species) |> 
  mutate(L = c("A", "B", "C")) |> 
  mutate(Species = sprintf("italic('I.')~italic('%s')~'(%s)'",  Species, L)) |> 
  unnest(data) |> 
  ggplot() + 
  geom_point(aes(x = Petal.Width, y = Sepal.Width, color = Species)) +
  geom_text(aes(x = 3, y = 5, label = Species), parse = TRUE, vjust = 1, hjust = 1,
            family = "notosans", size =3,  check_overlap = TRUE) +
  scale_x_continuous(name = xlabel, breaks = seq(0, 3), limits = c(0, 3)) +
  scale_y_continuous(name = ylabel, breaks = seq(0, 5), limits = c(0, 5)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, 
                      begin = 0, end = 0.5, labels = scales::parse_format()) +
  guides(color = "none") +
  facet_rep_grid(cols = vars(Species)) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        strip.background = element_blank(),
        strip.text = element_blank())
```
]

---

## 複数プロットの結合

.panelset[
.panel[.panel-name[Code]
```{r}
xlabel1 = "Petal width (cm)"
ylabel1 = "Sepal width (cm)"
xlabel2 = "Petal length (cm)"
ylabel2 = "Sepal length (cm)"

iris2 = iris |> 
    mutate(Species = sprintf("italic('I.')~italic('%s')",  Species))
```
]

.panel[.panel-name[Code Plot 1]
```{r}
plot1 = 
  ggplot(iris2) + 
  geom_point(aes(x = Petal.Width, y = Sepal.Width, color = Species)) +
  scale_x_continuous(name = xlabel1, breaks = seq(0, 8), limits = c(0, 8)) +
  scale_y_continuous(name = ylabel1, breaks = seq(0, 8), limits = c(0, 8)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, 
                      begin = 0, end = 0.5, labels = scales::parse_format()) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))
```
]

.panel[.panel-name[Code Plot 2]
```{r}
plot2 = 
  ggplot(iris2) + 
  geom_point(aes(x = Petal.Length, y = Sepal.Length, color = Species)) +
  scale_x_continuous(name = xlabel2, breaks = seq(0, 8), limits = c(0, 8)) +
  scale_y_continuous(name = ylabel2, breaks = seq(0, 8), limits = c(0, 8)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, 
                      begin = 0, end = 0.5, labels = scales::parse_format()) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))
```

]
]

---

## 複数プロットの結合の結果

```{r, fig.height=2.25}
ggarrange(plot1, plot2, 
          ncol = 2, nrow = 1,
          common.legend = TRUE, align = "hv")
```

---

## 線と点（説明変数は離散型変数の場合）

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.25}
ylabel = "Petal length (cm)"
iris2 |> group_by(Species) |> 
  summarise(PL = mean(Petal.Length),
            sd = sd(Petal.Length)) |> 
  mutate(lower = PL - sd,
         upper = PL + sd) |> 
ggplot() + 
  geom_line(aes(x = Species, y = PL, group = 1)) +
  geom_point(aes(x = Species, y = PL), size = 2, color = "white") +
  geom_point(aes(x = Species, y = PL), size = 1) +
  geom_errorbar(aes(x = Species, ymin = lower, ymax = upper),
                width = 0.0) +  
  scale_x_discrete(name = "Species", labels = scales::parse_format()) +
  scale_y_continuous(name = ylabel, breaks = seq(0, 8), limits = c(0, 8)) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))
```
]

---

## ボーグラフ

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.25}
ylabel = "Petal length (cm)"
iris2 |> group_by(Species) |> 
  summarise(PL = mean(Petal.Length),
            sd = sd(Petal.Length)) |> 
  mutate(lower = PL - sd,
         upper = PL + sd) |> 
ggplot() + 
  geom_col(aes(x = Species, y = PL, fill = Species)) +
  geom_errorbar(aes(x = Species, ymin = lower, ymax = upper),
                width = 0.01) +  
  scale_x_discrete(name = "Species", labels = scales::parse_format()) +
  scale_y_continuous(name = ylabel, breaks = seq(0, 8), limits = c(0, 8)) +
  scale_fill_viridis("", option = "turbo", discrete = TRUE, 
                      begin = 0, end = 0.5, labels = scales::parse_format()) +
  guides(fill = "none") +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))
```
]

---

## ボーグラフ（横向き・並び替える）

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.25}
ylabel = "Petal length (cm)"
iris2 |> group_by(Species) |> 
  summarise(PL = mean(Petal.Length),
            sd = sd(Petal.Length)) |> 
  mutate(lower = PL - sd,
         upper = PL + sd) |> 
  ggplot(aes(x = fct_reorder(Species, PL, .desc = T))) + 
  geom_col(aes(y = PL, fill = Species)) +
  geom_errorbar(aes(ymin = lower, ymax = upper),
                width = 0.1) +  
  scale_x_discrete(name = "Species", labels = scales::parse_format()) +
  scale_y_continuous(name = ylabel, breaks = seq(0, 8), limits = c(0, 8)) +
  scale_fill_viridis("", option = "turbo", discrete = TRUE, 
                      begin = 0, end = 0.5, labels = scales::parse_format()) +
  guides(fill = "none") +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10))+ 
  coord_flip()
```
]


---

## ヒストグラム

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.25}
xlabel = "Petal length (cm)"
ylabel = "Frequency"
iris2 |> 
  ggplot() + 
  geom_histogram(aes(x = Petal.Length, fill = Species)) +
  scale_x_continuous(name = xlabel) +
  scale_y_continuous(name = ylabel) +
  scale_fill_viridis("", option = "turbo", discrete = TRUE, 
                      begin = 0, end = 0.5, labels = scales::parse_format()) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(1,1),
        legend.justification = c(1,1))
```
]


---

## ヒストグラム・パネル

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.25}
xlabel = "Petal length (cm)"
ylabel = "Frequency"
iris2 |> 
  ggplot() + 
  geom_histogram(aes(x = Petal.Length, fill = Species),
                 binwidth = 0.1, center = 0) +
  scale_x_continuous(name = xlabel, limits = c(0, 10)) +
  scale_y_continuous(name = ylabel) +
  scale_fill_viridis("", option = "turbo", discrete = TRUE, 
                      begin = 0, end = 0.5, labels = scales::parse_format()) +
  facet_rep_wrap(facets = vars(Species)) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(1,1),
        legend.justification = c(1,1),
        strip.background = element_blank(),
        strip.text = element_blank())
```
]

---

## 時系列

データは (https://covid.ourworldindata.org/data/owid-covid-data.csv)。

.panelset[
.panel[.panel-name[Code 1]
```{r, echo = T, cache=TRUE}
covid = read_csv("https://covid.ourworldindata.org/data/owid-covid-data.csv")
covid2 = covid |> 
  group_by(continent, date) |> 
  summarise(tc = sum(total_cases_per_million, na.rm=T),
            td = sum(total_deaths_per_million, na.rm= T)) |> 
  drop_na()
```
]

.panel[.panel-name[Code 2]
```{r, fig.width=6, fig.height=2.0, eval = FALSE}
xlabel = "Date"
ylabel = "COVID cases per million"
ggplot(covid2) +
  geom_path(aes(x=date, y = tc, color = continent))+
  scale_x_date(name = xlabel) +
  scale_y_continuous(name = ylabel) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, begin = 0, end = 0.8) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(0,1),
        legend.justification = c(0,1),
        strip.background = element_blank(),
        strip.text = element_blank())
```
]

.panel[.panel-name[Output]
```{r, fig.width=6, fig.height=2.0, echo = FALSE}
xlabel = "Date"
ylabel = "COVID cases per million"
ggplot(covid2) +
  geom_path(aes(x=date, y = tc, color = continent))+
  scale_x_date(name = xlabel) +
  scale_y_continuous(name = ylabel) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, begin = 0, end = 0.8) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(0,1),
        legend.justification = c(0,1),
        strip.background = element_blank(),
        strip.text = element_blank())
```
]
]

---

## 時系列

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.25}
xlabel = "Date"
ylabel = "COVID cases per million"
ggplot(covid2) +
  geom_path(aes(x=date, y = tc, color = continent))+
  scale_x_date(name = xlabel, date_labels = "%Y-%m-%d") +
  scale_y_continuous(name = ylabel, 
                     breaks = 10^seq(-2,7), limits = c(0.01, 10^7),
                     trans = "log10", labels = scales::label_math(format = log10)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, begin = 0, end = 0.8) +
  guides(color = guide_legend(ncol = 2)) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(0.5,0),
        legend.justification = c(0,0),
        legend.background = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank())
```
]

---

## 時系列軸のカスタムラベル

```{r}
gnn_date = function() {
  function(x) {
    m = format(x, "%b")
    m = str_sub(m, start = 1, end = 1)
    y = format(x, "%Y")
    ifelse(duplicated(y), m, sprintf("%s\n%s", m,y))
  }
}
```

---

## 時系列

.panelset[
```{r, panelset = TRUE, fig.width=6, fig.height=2.25}
xlabel = "Date"
ylabel = "COVID cases per million"
ggplot(covid2) +
  geom_path(aes(x=date, y = tc, color = continent))+
  scale_x_date(name = xlabel, date_breaks = "months", labels = gnn_date()) +
  scale_y_continuous(name = ylabel, 
                     breaks = 10^seq(-2,7, by = 2), limits = c(0.01, 10^7),
                     trans = "log10", labels = scales::label_math(format = log10)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, begin = 0, end = 0.8) +
  guides(color = guide_legend(ncol = 2)) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(0.5,0),
        legend.justification = c(0,0),
        legend.background = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank())
```
]

---

## 箱ひげ図

.panelset[

.panel[.panel-name[Code 1]
```{r}
covid2 = covid |> 
  filter(date >= lubridate::ymd("2021-01-01")) |> 
  filter(str_detect(location, "Indonesia|Japan|South Korea|Taiwan|China"))
```
]

.panel[.panel-name[Code 2]
```{r boxplot-covid, fig.height=2.25, eval=FALSE}
xlabel = "Country"
ylabel = "Daily cases per million"
ggplot(covid2) +
  geom_boxplot(aes(x = fct_reorder(location, new_cases_per_million, mean, na.rm=T, .desc=T), 
                   y = new_cases_per_million, fill = location)) + 
  scale_x_discrete(name = xlabel) +
  scale_y_continuous(name = ylabel, 
                     breaks = 10^seq(-3,3, by = 1), limits = 10^c(-3, 3),
                     trans = "log10", labels = scales::label_math(format = log10)) +
  scale_color_viridis("", option = "turbo", discrete = TRUE, begin = 0, end = 0.8) +
  guides(fill = guide_legend(ncol = 2)) +
  theme_pubr(base_family = "notosans") +
  theme(text = element_text(size = 10),
        legend.position = c(0,0),
        legend.justification = c(0,0),
        legend.background = element_blank(),
        legend.title = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank())
```
]
.panel[.panel-name[Output]
```{r, ref.label="boxplot-covid", fig.height=2.25, echo=FALSE}

```
]
]
